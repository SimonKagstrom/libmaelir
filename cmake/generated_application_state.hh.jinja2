#pragma once

#include <cstdint>
#include <memory>
#include <string>

namespace AS
{

constexpr auto kLastIndex = {{ max_index }};

{% for parameter in parameters %}
struct {{ parameter.name }}
{
    {{parameter.type}} {{ parameter.name }};

    template<typename T>
    auto &GetRef();

    static consteval bool IsAtomic()
    {
        return {{ parameter.is_atomic|lower }};
    }
};

template<>
inline auto &{{ parameter.name }}::GetRef<struct {{ parameter.name }}>()
{
    return {{parameter.name}};
}


{% endfor %}


template<typename T>
auto DefaultValue();

{% for asp in application_state_parameters %}
template<>
consteval auto DefaultValue<struct {{ asp.parameter.name }}>()
{
    return {{ asp.default_value }};
};
{% endfor %}


template<typename T>
auto IndexOf();

{% for asp in application_state_parameters %}
template<>
consteval auto IndexOf<struct {{ asp.parameter.name }}>()
{
    return {{ asp.index }};
};
{% endfor %}


namespace storage
{
// Dummy function to cause a linker error if an orphan parameter is accessed
bool &OrphanNotFound();

struct state
{
    {%- for asp in application_state_parameters %}
    {%- if asp.parameter.is_atomic == false %}
    std::shared_ptr<{{ asp.parameter.type }}> {{ asp.parameter.name }};
    {%- else %}
    {{ asp.parameter.type }} {{ asp.parameter.name }};
    {%- endif %}
    {%- endfor %}


    template<typename T>
    auto &GetRef();

    void SetupDefaultValues();
};

{% for asp in application_state_parameters %}
template<>
inline auto &state::GetRef<struct {{ asp.parameter.name }}>()
{
    return {{asp.parameter.name}};
}
{% endfor %}

{% for param in orphans %}
template<>
inline auto &state::GetRef<struct {{ param.name }}>()
{
    return OrphanNotFound();
}
{% endfor %}

} // namespace storage

} // namespace AS